# Author: Michael Gatto
# Description: Implement most of the classic chinese game of XiangQi


import itertools
from collections import OrderedDict
from typing import Any, List, Tuple, Set, Union, Dict, Optional


class Piece:
    """ Abstract class to represent the concept of a game piece """

    def __init__(self):
        self._team: str = ""  # prevents accidentally moving the wrong team's piece
        self._id: int = 0
        self._starting_positions: List[Tuple[str, int]]
        self._current_position: Optional[Tuple[str, int]] = None

    def get_team(self) -> str:
        """ Returns the team's color

        :return: {str} The label of the piece's team; "red" or "black"
        """
        return self._team

    def get_id(self) -> int:
        """ Return the piece's id, set when it was placed onto the field of battle """
        return self._id

    def set_id(self, id: int) -> None:
        """ Sets the id of the piece so we can distinguish pieces of the same echelon """
        self._id = id

    def get_position(self) -> Optional[Tuple[str, int]]:
        """ Get the piece's current position; could be null """
        return self._current_position

    def set_position(self, position: Optional[Tuple[str, int]]) -> None:
        """ Updates the piece's board position; may be a new position or nulls it """
        self._current_position = position

    def get_starting_position(self, i: int) -> Tuple[str, int]:
        """ Simple accessor to private var """
        return self._starting_positions[i]

    def get_move_sequence(self, vector: List[Tuple[str, int]], origin: Tuple[str, int], destination: Tuple[str, int]) -> List:
        """ Returns the exact sequence of positions over which the piece will move

        :param vector: {List[Tuple[str, int]]} one of the maximum possible moves list of positions generated by the piece's ruleset
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {List} an empty list if origin and destination are the same, a List of Tuples (positions) otherwise
        """
        vec_params = dict()

        for k, point in enumerate(vector):
            if point == origin:
                # record the k as start
                vec_params["start"] = k
            elif point == destination:
                # record the end index, which will need an offset later
                vec_params["end"] = k

        # adjust the ending depending on direction from origin to destination
        vec_params["end"] -= 1 if vec_params["start"] > vec_params["end"] else -1  # x - -1 == x+1 vs x - 1

        # default direction is least to greatest; reversed otherwise, especially for black chariots, cannons
        direction = -1 if vec_params["start"] > vec_params["end"] else 1

        return vector[vec_params["start"]:vec_params["end"]:direction]


class Board:
    """ Represents a XinagQi game board """

    # Note: its the intersection of lines where pieces are placed and play; think of the lines as "roads"

    def __init__(self, red: Any, black: Any):
        self._red_army = red
        self._black_army = black

        d = OrderedDict()

        columns = list(map(lambda x: chr(x), range(ord('a'), ord('a') + 9)))
        for i in columns:
            d[i] = ["" for x in range(10)]

        self._layout = d

        # create list of tuples for the entire board
        self._all_region = list(itertools.product(columns, list(range(0, 10))))

        # "Row 1 being the Red side and row 10 the Black side"
        self._red_region = list(itertools.product(columns, list(range(0, 5 + 1))))
        self._black_region = list(itertools.product(columns, list(range(5, 9 + 1))))

        self._red_castle = list(itertools.product(["d", "e", "f"], [0, 1, 2]))
        self._black_castle = list(itertools.product(["d", "e", "f"], [7, 8, 9]))

        # place Armies into their starting positions
        for army_team in [red, black]:
            # loop through the Army dict and add each piece to the board
            for echelon, pieces in army_team.get_personnel().items():
                i = 0
                for piece in pieces:
                    start = piece.get_starting_position(i)
                    piece.set_id(i + 1)

                    # copy the piece reference into dict key's correct list position
                    self._layout[start[0]][start[1]] = piece
                    piece.set_position(start)

                    i += 1

    def __repr__(self):
        """ Represent the class and its attributes for debugging purposes """
        print_layout = ""

        for k in range(0, 10):
            print_layout += f"{str(k+1)}" + str(" " * 2 if k+1 < 10 else " ")

            for j, col in enumerate(self._layout):
                # 3 chars per makes everything aligned, and still fits a game piece's __repr__ in place of the middle char
                if self._layout[col][k] == "":
                    print_layout += f"[{' ' * 3}]"
                else:
                    print_layout += f"[ {self._layout[col][k]} ]"

            print_layout += "\n"

            if k == 4:
                print_layout += f"   {'~' * 5 * 9}\n"

        print_layout += "   "
        for key in self._layout:
            print_layout += f"  {key}  "

        # TODO try to refactor using .join() in some way instead of a whole line just to append a break
        print_layout += "\n"

        return print_layout

    def __getitem__(self, item):
        """ allow access to the object's attributes through dynamically built keys """
        return getattr(self, item)

    def get_army_of(self, team: str) -> Any:  # should be "Army", but circular references to types...meh
        """ Provide the team's army, i.e. a collection of its personnel  """
        return self[f"_{team}_army"]

    def get_region_of(self, position: Tuple[str, int]) -> str:
        """ Return the current region of the supplied position

        :param position: {Tuple[str, int]} coordinate of a position on the board
        :return: {str} The label of the region: one of "red" or "black"
        """
        if position in self._red_region == "red":
            return "red"
        else:
            return "black"

    def is_in_red_region(self, position: Tuple[str, int]) -> bool:
        """ """
        return position in self._red_region

    def is_in_black_region(self, position: Tuple[str, int]) -> bool:
        """ """
        return position in self._black_region

    def is_within_board(self, position: Tuple[str, int]) -> bool:
        """

        :param position: {Tuple[str, int]} coordinate of a position on the board
        :return: {bool} True if the position is within the boundary of the board, False otherwise
        """
        return position in self._all_region

    def get_castle_of(self, team: str) -> List[Tuple[str, int]]:
        """ Provide all the points of the team's castle """
        return self[f"_{team}_castle"]

    def is_in_red_castle(self, position: Tuple[str, int]) -> bool:
        """ Is the position within Red Team's castle?

        :param position: {Tuple[str, int]} coordinate of a position on the board
        :return: {bool} True if the position is within Red's castle, false otherwise
        """
        return position in  self._red_castle

    def is_in_black_castle(self, position: Tuple[str, int]) -> bool:
        """ Is the position within Black Team's castle?

        :param position: {Tuple[str, int]} coordinate of a position on the board
        :return: {bool} True if the position is within Red's castle, false otherwise
        """
        return position in self._black_castle

    def get_contents_of(self, position: Tuple[str, int]) -> Union[str, Piece]:
        """ Return whatever is at the supplied position

        :param position: {Tuple[str, int]} coordinate of a position on the board
        :return: {Union[str, Piece]} either a blank string else an instance of a child class of Piece
        """
        return self._layout[position[0]][position[1]]

    def set_contents_of(self, position: Tuple[str, int], content: Union[str, Piece]) -> bool:
        """ Update what stands at the supplied position

        :param position: {Tuple[str, int]} coordinate of a position on the board
        :param content: {Union[str, Piece]} either a sub-class of Piece or an empty string, to empty the space
        :return: {bool} True if successful, false otherwise
        """
        try:
            self._layout[position[0]][position[1]] = content
        except KeyError:
            return False

        return True

    def get_threats_to(self, team: str, target_position: Tuple[str, int]) -> Set[Optional[Piece]]:
        """ Scan for any way that the enemy could threaten the opposing General

        :param team: {str} The opposing team to that which is making a move
        :param target_position: {Tuple[str, int]} coordinate of a position on the board
        :return: Set[Optional[Piece]] a set of threatening pieces, or an empty set otherwise
        """

        # get all enemy's existing pieces
        enemy: Army = self.get_army_of("black" if team == "red" else "red")

        threats = set()

        # looping through them, check is the move against our general is legal
        for echelon, group in enemy.get_personnel().items():
            # "skip Advisers/Generals/Elephants, since they cannot get to the other side of the board" - Neranjan Kuppuswamy
            if echelon in ['general', 'advisors', 'elephants']:
                continue
            else:
                # print(echelon)
                for warrior in group:
                    # print(warrior)
                    if warrior.is_move_legal(self, warrior.get_position(), target_position):
                        # add the threats
                        threats.add(warrior)

        return threats

    def will_expose_general(self, team: str, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the move will expose the team's general or not

        :param team: {str} The current team which is making a move
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move will expose their own general, False otherwise
        """

        # Q: is there a direct line of sight to the other team's general as a result of this move??

        # First, get the team's general

        team_castle = self.get_castle_of(team)
        for point in team_castle:
            if isinstance(self.get_contents_of(point), General):
                # create a straight-line vector from our general, since both are confined to their respective castles
                if team == "red":
                    # endpoint is edge of board in "black"'s area
                    vec = list(itertools.product([point[0]], list(range(point[1], 10))))
                else:
                    # endpoint is edge of board in "red"'s area
                    vec = list(itertools.product([point[0]], list(range(point[1], -1, -1))))

                # only continue if the moving piece is in that vector
                if origin in vec:
                    # So, walk the straight line to the other team's castle, excluding origin: General is there?
                    found_pieces = 0
                    enemy_general_present = False

                    # the vector starts at the origin and goes to the opposite end of the board; no reversing needed
                    for position in vec[1:]:
                        if self.get_contents_of(position) != "":
                            # there's somebody between our general and whatever is out there on the field
                            found_pieces += 1

                            # now, we're searching the enemy castle to see if could be in our general's line of sight
                            if self[f"is_in_{'black' if team == 'red' else 'red'}_castle"](position) \
                                    and isinstance(self.get_contents_of(point), General):
                                # we found the enemy General!
                                enemy_general_present = True

                                break  # no need to find other pieces possibly behind the general

                    # found_pieces includes the piece to be moved and the enemy general, but not our general because vec[1:]
                    if enemy_general_present and found_pieces == 2:
                        # so, if the piece to be moved goes out of the column, our general is done
                        if destination[0] != origin[0]:
                            return True
                        else:
                            return False
                else:
                    # the piece to be moved is not even relevant
                    break

        return False


class General(Piece):
    """ Represents a General/King """

    def __init__(self, team: str):
        super().__init__()

        self._team = team
        self._starting_positions = [("e", 0 if team == "red" else 9)]

    def __str__(self):
        """ Symbol only representation for game board viewing """
        return "G" if self._team == "red" else "g"

    def __repr__(self):
        """ Print out a General's representation depending on team """
        return f"<{'G' if self._team == 'red' else 'g'} id={self._id} team={self._team} start={self._starting_positions} location={self._current_position}>"

    def get_legal_destinations(self, game_board: Board, origin: Tuple[str, int]) -> List[Tuple[str, int]]:
        """ Special method to be used in both finding legal moves as well as is_in_check

        :param game_board:
        :param origin:
        :return:
        """

        # a set of tuples representing legal destinations; max 4 possible moves: combo of row +-1 OR col +-1
        opportunities: Set[Tuple[str, int]] = {
            (origin[0], origin[1] + 1),  # move right 1
            (origin[0], origin[1] - 1),  # move left 1
            (chr(ord(origin[0]) - 1), origin[1]),  # move up 1
            (chr(ord(origin[0]) + 1), origin[1])  # move down 1
        }

        legal_destinations = []

        # check the correct team's castle, and if an opposing piece is at the destination
        for o in opportunities:
            # since it moves only 1 space, destination can be any point in opportunities on the board
            if game_board[f"is_in_{self._team}_castle"](o):
                legal_destinations.append(o)

        return legal_destinations

    def is_move_legal(self, game_board: Board, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the desired destination is legal for this piece

        :param game_board: {Board} the complete board object
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move is legal, False if its illegal
        """

        legal_destinations = self.get_legal_destinations(game_board, origin)

        at_destination: Union[str, Piece] = game_board.get_contents_of(destination)
        if destination in legal_destinations and (at_destination == "" or at_destination.get_team() != self._team):
            return True

        return False


class Advisor(Piece):
    """ Represents an advisor to the General """

    def __init__(self, team: str):
        super().__init__()

        self._team = team

        if team == "red":
            self._starting_positions = list(itertools.product(["d", "f"], [0]))
        else:
            self._starting_positions = list(itertools.product(["d", "f"], [9]))

    def __str__(self):
        """ Symbol only representation for game board viewing """
        return "A" if self._team == "red" else "a"

    def __repr__(self):
        """ Print out an Advisor's representation depending on team """
        return f"<{'A' if self._team == 'red' else 'a'} id={self._id} team={self._team} location={self._current_position}>"  #  start={self._starting_positions}

    def is_move_legal(self, game_board: Board, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the desired destination is legal for this piece

        :param game_board: {Board} the complete board object
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move is legal, False if its illegal
        """

        # a set of tuples representing legal destinations; max 4 possible moves: row +-1 OR col +-1
        opportunities = {
            # offset both +- 1
            (chr(ord(origin[0]) - 1), origin[1] + 1),  # move down and left
            (chr(ord(origin[0]) - 1), origin[1] - 1),  # move up and left
            (chr(ord(origin[0]) + 1), origin[1] + 1),  # move down and right
            (chr(ord(origin[0]) + 1), origin[1] - 1)  # move up and right
        }

        # Filter the possibilities by specific conditions:
        #   * is the destination within team's castle?
        #   * is the destination not already occupied by a friendly piece?
        legal_destinations = []

        # check the correct team's castle, and if an opposing piece is at the destination
        for o in opportunities:
            # since it moves only 1 space, destination can be any point in opportunities on the board
            if game_board[f"is_in_{self._team}_castle"](o):
                legal_destinations.append(o)

        at_destination: Union[str, Piece] = game_board.get_contents_of(destination)
        if destination in legal_destinations and (at_destination == "" or at_destination.get_team() != self._team):
            return True

        return False


class Elephant(Piece):
    """ Represents an elephant piece; AKA Minister """

    def __init__(self, team: str):
        super().__init__()

        self._team = team

        if team == "red":
            self._starting_positions = list(itertools.product(["c", "g"], [0]))
        else:
            self._starting_positions = list(itertools.product(["c", "g"], [9]))

    def __str__(self):
        """ Symbol only representation for game board viewing """
        return "E" if self._team == "red" else "e"

    def __repr__(self):
        """ Print out an Elephant's representation depending on team """
        return f"<{'E' if self._team == 'red' else 'e'} id={self._id} team={self._team} start={self._starting_positions} location={self._current_position}>"

    def is_move_legal(self, game_board: Board, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the desired destination is legal for this piece

        :param game_board: {Board} the complete board object
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move is legal, False if its illegal
        """

        # list of vectors of magnitude 2: sub-list of two tuples, mapping the complete list of moves diagonally.
        # if origin = ["c", 3], then opportunities = [[('b', 1), ('a', 0)], [('b', 3), ('a', 4)], [('d', 1), ('e', 0)], [('d', 3), ('e', 4)]]
        opportunities = []
        y_s = [y for y in range(origin[1] - 2, origin[1] + 2 + 1) if y !=  origin[1]]  # exclude the origin
        x_s = [chr(x) for x in range(ord(origin[0]) - 2, ord(origin[0]) + 2 + 1) if x != ord(origin[0])]  # exclude the origin

        for n_s in [x_s[1::-1], x_s[2:]]:  # reversed d,e which we don't want x_s[:-3:-1]
            # first, one half of the sides
            vec = []
            # these are letter-reversed... so, rotate!
            for k, n in enumerate(list(reversed(n_s))):
                vec.append((n, y_s[k]))
            # reverse the order...
            opportunities.append(list(reversed(vec)))

            # now, the other half
            vec = []
            for k, n in enumerate(n_s):
                vec.append((n, y_s[k + 2]))
            opportunities.append(vec)

        # filter for legal moves
        legal_paths = []

        # looping through a list of lists...
        for o in opportunities:
            # cannot cross the river; i.e must stay within its own region; nicely achieves checking board boundary, too!
            #   thus, both points in the vector must be within the region
            if game_board[f"is_in_{self._team}_region"](o[0]) and game_board[f"is_in_{self._team}_region"](o[1]):
                legal_paths.append(o)

        # find the destination tuple as the second tuple of any vector in the legal_paths collection
        for d in legal_paths:
            if d[1] == destination:
                # OK, here is our sub-vector

                # "This piece can be blocked by another piece on the intervening square"
                #   i.e. the space between origin and destination intervening space must be empty = d[0], the first
                #   tuple in any sub-list. AND, a friendly piece may not be at the destination
                in_between: Union[str, Piece] = game_board.get_contents_of(d[0])
                at_destination: Union[str, Piece] = game_board.get_contents_of(d[1])

                if in_between == "" and (at_destination == "" or at_destination.get_team() != self._team):
                    return True

        return False


class Horse(Piece):
    """ Represents a Horse """

    def __init__(self, team: str):
        super().__init__()

        self._team = team

        if team == "red":
            self._starting_positions = list(itertools.product(["b", "h"], [0]))
        else:
            self._starting_positions = list(itertools.product(["b", "h"], [9]))

    def __str__(self):
        """ Symbol only representation for game board viewing """
        return "H" if self._team == "red" else "h"

    def __repr__(self):
        """ Print out an Horse's representation depending on team """
        return f"<{'H' if self._team == 'red' else 'h'} id={self._id} team={self._team} start={self._starting_positions} location={self._current_position}>"

    def is_move_legal(self, game_board: Board, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the desired destination is legal for this piece

        :param game_board: {Board} the complete board object
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move is legal, False if its illegal
        """

        # list of vectors of magnitude 2: sub-list of two tuples,
        # mapping the complete list of 1 move horizontal or vertical then 1 move diagonally.
        opportunities = []

        # note the patterns are symmetrical about an axis
        # pattern = [(h+-1, v), (h-2, v+-1)]
        left_start = (chr(ord(origin[0]) - 1), origin[1])
        right_start = (chr(ord(origin[0]) + 1), origin[1])

        # pattern = [(h, v+-1), (h+-1), v-2]
        up_start = (origin[0], origin[1] + 1)
        down_start = (origin[0], origin[1] - 1)

        for k, n in enumerate([1, 1]):
            left_vec = [left_start, (chr(ord(left_start[0]) - 1), int(left_start[1] + n*(-1)**(k-1)))]  # <- alternate between 1 and -1
            right_vec = [right_start, (chr(ord(right_start[0]) + 1), int(right_start[1] + n*(-1)**(k-1)))]

            up_vec = [up_start, (chr(int(ord(up_start[0]) + n*(-1)**(k-1))), up_start[1] + 1)]
            down_vec = [down_start, (chr(int(ord(down_start[0]) + n*(-1)**(k-1))), down_start[1] - 1)]

            opportunities.extend([left_vec, right_vec, up_vec, down_vec])

        # filter for legal moves
        legal_paths = []

        for o in opportunities:
            # each point in the vector must be within the board
            if game_board.is_within_board(o[0]) and game_board.is_within_board(o[1]):
                legal_paths.append(o)

        # find the destination tuple as the second tuple of any vector in the legal_paths collection
        for d in legal_paths:
            # "This piece can be blocked by another piece on the intervening square"
            #   i.e. the space between origin and destination intervening space must be empty = d[0], the first
            #   tuple in any sub-list.

            # only check the empty-intervening-spot condition for the actual destination
            if d[1] == destination:
                # OK, here is our sub-vector
                in_between: Union[str, Piece] = game_board.get_contents_of(d[0])
                at_destination: Union[str, Piece] = game_board.get_contents_of(d[1])  # = game_board._layout[d[0][0]][d[0][1]]

                if in_between == "" and (at_destination == "" or at_destination.get_team() != self._team):
                    return True

        return False


class Chariot(Piece):
    """ Represents a Chariot """

    def __init__(self, team: str):
        super().__init__()

        self._team = team

        if team == "red":
            self._starting_positions = list(itertools.product(["a", "i"], [0]))
        else:
            self._starting_positions = list(itertools.product(["a", "i"], [9]))

    def __str__(self):
        """ Symbol only representation for game board viewing """
        return "R" if self._team == "red" else "r"

    def __repr__(self):
        """ Print out an Elephant's representation depending on team """
        return f"<{'R' if self._team == 'red' else 'r'} id={self._id} team={self._team} start={self._starting_positions} location={self._current_position}>"

    def is_move_legal(self, game_board: Board, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the desired destination is legal for this piece

        :param game_board: {Board} the complete board object
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move is legal, False if its illegal
        """

        # vectors of varying magnitude, depending on the move's origin: a sub-list of 1 or more tuples,
        # mapping the complete list of n positions horizontally or vertically.
        up_vec = list(itertools.product([origin[0]], list(range(origin[1], 10))))  # endpoint is edge of board
        down_vec = list(itertools.product([origin[0]], list(range(origin[1], -1, -1))))  # endpoint is edge of board

        # chr(97) == "a"; chr(105) == "i"
        right_vec = list(itertools.product([chr(x) for x in range(ord(origin[0]), 105 + 1)], [origin[1]]))
        left_vec = list(itertools.product([chr(x) for x in range(ord(origin[0]), 97 - 1, -1)], [origin[1]]))

        # build the list while excluding empty lists (i.e. if it goes off the board)
        opportunities = [vec for vec in [up_vec, down_vec, right_vec, left_vec] if vec and len(vec) > 1]
        # omit vecs which consist only of the origin...

        # Note: off board moves will be an empty list, to be filtered later
        # Also, -10 might be reversed for black, but the end result for up/down all
        # gets merged into the opportunities list of vectors without labels, so ok.

        for vec in opportunities:
            # loop through each tuple to see if is the destination within any vector and if there's no blocking piece
            for n, position in enumerate(vec):
                if position == destination:
                    # OK, here is our sub-vector; search it for blocking pieces.
                    move_sequence = self.get_move_sequence(vec, origin, destination)

                    for point in move_sequence[1:]:  # sequence includes origin, so start + 1
                        at_position: Union[str, Piece] = game_board.get_contents_of(point)

                        # not a legal move if there's a piece in between us and the destination
                        if at_position != "" and point != destination:
                            return False
                        # special case for the destination: OK if its an enemy piece -> capture!
                        else:
                            # check for a halting condition: Opps, a friendly piece is at the destination!
                            if at_position != "" and at_position.get_team() == self._team:
                                return False

                    return True

        return False


class Cannon(Piece):
    """ Represents a Cannon """

    def __init__(self, team: str):
        super().__init__()

        self._team = team

        if team == "red":
            self._starting_positions = list(itertools.product(["b", "h"], [2]))
        else:
            self._starting_positions = list(itertools.product(["b", "h"], [7]))

    def __str__(self):
        """ Symbol only representation for game board viewing """
        return "C" if self._team == "red" else "c"

    def __repr__(self):
        """ Print out an Elephant's representation depending on team """
        return f"<{'C' if self._team == 'red' else 'c'} id={self._id} team={self._team} location={self._current_position}>"  #  start={self._starting_positions}

    def is_move_legal(self, game_board: Board, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the desired destination is legal for this piece

        :param game_board: {Board} the complete board object
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move is legal, False if its illegal
        """

        # vectors of varying magnitude, depending on the move's origin: a sub-list of 1 or more tuples,
        # mapping the complete list of n positions horizontally or vertically.
        up_vec = list(itertools.product([origin[0]], list(range(origin[1], 10))))  # +1 for each??
        down_vec = list(itertools.product([origin[0]], list(range(origin[1], -1, -1))))

        # chr(97) == "a"; chr(105) == "i"
        right_vec = list(itertools.product([chr(x) for x in range(ord(origin[0]), 105 + 1)], [origin[1]]))
        left_vec = list(itertools.product([chr(x) for x in range(ord(origin[0]), 97 - 1, -1)], [origin[1]]))

        # build the list while excluding empty lists (i.e. if it goes off the board)
        opportunities = [vec for vec in [up_vec, down_vec, right_vec, left_vec] if vec and len(vec) > 1]
        # Note: off board moves will be an empty list, to be filtered later

        # find the destination tuple as the second tuple of any vector in the legal_paths collection
        for vec in opportunities:
            # loop through each tuple to see if is the destination within any vector and if there's no blocking piece
            for n, position in enumerate(vec):
                if position == destination:
                    # OK, here is our sub-vector!

                    # may only jump a single piece to capture an enemy piece at the destination
                    capture_candidate: Union[str, Piece] = game_board.get_contents_of(destination)
                    if capture_candidate != "" and capture_candidate.get_team() != self._team:
                        # now is there a single piece, any team between here and there or not??
                        total_pieces_present = 0

                        # search the move sequence for blocking or enabling conditions
                        move_sequence = super().get_move_sequence(vec, origin, destination)
                        # exclude the destination and go only up to next-to-last position;
                        #   we already know an opponent is waiting there
                        for point in move_sequence[1:-1]:  # sequence includes origin, so start + 1
                            if game_board.get_contents_of(point) != "":
                                total_pieces_present += 1

                        if total_pieces_present > 1 or total_pieces_present == 0:
                            return False

                        return True
                    # there is no capture candidate at the destination; move like a Chariot
                    else:
                        # search it for blocking pieces; cannot capture in this "chariot" mode.
                        # thus, there may be NO pieces at the destination
                        move_sequence = self.get_move_sequence(vec, origin, destination)
                        for point in move_sequence[1:]:  # sequence includes origin, so start + 1
                            if game_board.get_contents_of(point) != "":
                                return False

                        return True

        return False


class Soldier(Piece):
    """ Represents a Soldier """

    def __init__(self, team: str):
        super().__init__()

        self._team = team

        # self._starting_positions = list(itertools.product(["a", "c", "e", "g", "i"], [3] if team == "red" else [6]))
        if team == "red":
            self._starting_positions = list(itertools.product(["a", "c", "e", "g", "i"], [3]))
        else:
            self._starting_positions = list(itertools.product(["a", "c", "e", "g", "i"], [6]))

        # enhanced moves possible when True
        self._has_crossed_river = False

    def __str__(self):
        """ Symbol only representation for game board viewing """
        return "S" if self._team == "red" else "s"

    def __repr__(self):
        """ Print out an Elephant's representation depending on team """
        # start = {self._starting_positions}
        return f"<{'S' if self._team == 'red' else 's'} id={self._id} team={self._team} location={self._current_position} across={self._has_crossed_river}>"

    def record_crossing(self):
        """ Update the Soldier's river-crossing status; once crossed may never return """
        self._has_crossed_river = True

    def is_move_legal(self, game_board: Board, origin: Tuple[str, int], destination: Tuple[str, int]) -> bool:
        """ Determine if the desired destination is legal for this piece

        :param game_board: {Board} the complete board object
        :param origin:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param destination: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: {bool} True if the move is legal, False if its illegal
        """

        # moves only 1 point forward until crossing the river
        opportunities = []

        if self._team == "red":
            forward = (origin[0], origin[1] + 1)
        else:
            forward = (origin[0], origin[1] - 1)

        opportunities.append(forward)

        if self._has_crossed_river:
            # add right and left moves, 1 pt (never backwards)
            left = (chr(ord(origin[0]) - 1), origin[1])
            right = (chr(ord(origin[0]) + 1), origin[1])

            opportunities.extend([left, right])

        legal_destinations = []

        # check the correct team's castle
        for o in opportunities:
            if game_board.is_within_board(o):
                legal_destinations.append(o)

        at_destination: Union[str, Piece] = game_board.get_contents_of(destination)
        if destination in legal_destinations and (at_destination == "" or at_destination.get_team() != self._team):
            return True

        return False


class Army:
    def __init__(self, team: str):
        if team not in ["red", "black"]:
            raise AttributeError("Army team must be either red or black")

        self._team = team

        # construct an army of pieces as a dictionary. Elements are sets of like pieces, because order is irrelevant
        self._personnel = {
            "general": {General(team)},
            "advisors": {Advisor(team), Advisor(team)},
            "elephants": {Elephant(team), Elephant(team)},
            "horses": {Horse(team), Horse(team)},
            "cannons": {Cannon(team), Cannon(team)},
            "chariots": {Chariot(team), Chariot(team)},
            "soldiers": {Soldier(team), Soldier(team), Soldier(team), Soldier(team), Soldier(team)}
        }  # 16

    def __repr__(self):
        return f"<Army personnel={self._personnel}>"

    def get_personnel(self) -> Dict:
        """ Get all the team's pieces as a group

        :return: {Dict} of echelons and then sets of the pieces in that echelon
        """
        return self._personnel

    def disenroll(self, unfortunate_soul: Piece) -> bool:
        """ Remove a fallen comrade from the team's army

        :param unfortunate_soul: {piece} t
        :return: {bool} True if enrolled was disenrolled from the Army, False otherwise
        """

        echelon = self._personnel[f"{type(unfortunate_soul).__name__.lower()}s"]
        for martyr in echelon:
            if martyr.get_id() == unfortunate_soul.get_id():
                try:
                    unfortunate_soul.set_position(None)
                    echelon.remove(unfortunate_soul)
                except KeyError:
                    return False

                return True

        return False


class XiangqiGame:
    """ Represents a game play for XiangQi """

    def __init__(self):
        self._states: List[str] = ["UNFINISHED", "RED_WON", "BLACK_WON"]
        self._game_state = "UNFINISHED"
        self._board = Board(Army("red"), Army("black"))
        self._current_turn_is_for = "red"

    def __repr__(self):
        """ Representation of the XinagQi game class for debugging and peeking """
        return f"<XiangqiGame state={self._game_state} turn={self._current_turn_is_for} \n{self._board}>"

    def get_game_state(self) -> str:
        """ Return the private variable storing the game's current state """
        return self._game_state

    def is_in_check(self, team: str) -> bool:
        """ Decides whether the team in question is checkmated or not

        :param team: {str}  The current team which may or may not be in checkmate
        :return: {bool}  Returns True if that player is in check, but returns False otherwise
        """

        # paranoid validation...
        if team not in ["red", "black"]:
            return False

        # You do not have to implement the rules regarding perpetual check or chasing.
        # You do need to correctly handle stalemate.

        # Q. is the General even in Check? :
        # 1. get our general's position
        our_general = None
        our_general_location = None

        team_castle = self._board.get_castle_of(team)
        for point in team_castle:
            piece = self._board.get_contents_of(point)

            if isinstance(piece, General):
                our_general = piece
                our_general_location = point
                break

        threats = self._board.get_threats_to(team, our_general_location)

        # doesn't matter if General can't move, because its not in danger
        if len(threats) == 0:
            return False
        else:
            # Can our General move anywhere?
            ways_out = our_general.get_legal_destinations(self._board, our_general_location)
            if len(ways_out) > 0:
                # check if each way_out tuple is itself vulnerable; Yes = NO Move, yo!
                remaining_threats = 0
                for escape_hatch in ways_out:
                    threats = self._board.get_threats_to(team, escape_hatch)
                    if len(threats):
                        remaining_threats += 1

                if remaining_threats >= len(ways_out):
                    return True

                return False
            else:  # same as len(ways_out) == 0
                return True

    def make_move(self, from_position: str, to_position: str) -> bool:
        """ Move the piece from a position to a new one.

        :param from_position:  {Tuple[str, int]} the originating point of the move, AKA where the piece stands now
        :param to_position: {Tuple[str, int]} the terminal point of the move, i.e. goal of the movement
        :return: True if the move conforms to the piece's ruleset, False otherwise
        """

        # short circuit the move if it no longer makes sense
        if self._game_state != "UNFINISHED":
            return False

        # parsing raw input into a Tuple[str, int]; lists start from 0 so subtract 1!
        origin: Tuple[str, int] = (str(from_position[0]).lower(), int(from_position[1:]) - 1)
        destination: Tuple[str, int] = (str(to_position[0]).lower(), int(to_position[1:]) - 1)

        # the piece must belong to the team whose move it currently is
        piece_in_movement: Union[str, Piece] = self._board.get_contents_of(origin)
        if piece_in_movement.get_team() is not self._current_turn_is_for:
            return False

        # Does this move expose the current team's own general?
        # "generals aren't allowed to "see" each other"
        if self._board.will_expose_general(self._current_turn_is_for, origin, destination):
            return False

        if piece_in_movement.is_move_legal(self._board, origin, destination):
            # update its position on the board
            piece_in_movement.set_position(destination)

            # handle a capture
            at_destination = self._board.get_contents_of(destination)
            # we assume if anything is there, its an enemy piece else the move would not be legal ^
            if at_destination != "":
                # remove it from the Army; this is needed for the Army scan later for is_in_check logic
                team_army: Army = self._board.get_army_of(at_destination.get_team())

                # remove this specific piece from the board
                team_army.disenroll(at_destination)

            self._board.set_contents_of(destination, piece_in_movement)
            self._board.set_contents_of(origin, "")

            # if soldier, update its "river"-crossing status
            if isinstance(piece_in_movement, Soldier) and self._board.get_region_of(destination) != piece_in_movement.get_team():
                piece_in_movement.record_crossing()

            next_move_making_team: str = "black" if self._current_turn_is_for == "red" else "red"

            # run the check on the opposing team of the one which just made the move
            if self.is_in_check(next_move_making_team):
                # the current team is in check; opposing team wins!
                self._game_state = f"{self._current_turn_is_for.upper()}_WON"

            # switch turns!
            self._current_turn_is_for = next_move_making_team

            return True

        # fail-safe
        return False
